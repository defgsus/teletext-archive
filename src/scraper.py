import os
import sys
from pathlib import Path
from typing import Generator, Tuple, Union

import requests

scraper_classes = dict()


class Scraper:

    # must be filename compatible
    NAME: str = None
    # set to True in abstract classes
    ABSTRACT: bool = False

    NUM_PAGE_DIGITS: int = 3
    NUM_SUB_PAGE_DIGITS: int = 2
    FILE_EXTENSION: str = "html"

    # request timeout in seconds
    REQUEST_TIMEOUT: float = 5

    BASE_PATH: Path = Path(__file__).resolve().parent.parent / "docs" / "snapshots"

    def __init_subclass__(cls, **kwargs):
        if not cls.ABSTRACT:
            assert cls.NAME, f"Define {cls.__name__}.NAME"
        if cls.NAME in scraper_classes:
            raise AssertionError(f"Duplicate name '{cls.NAME}' for class {cls.__name__}")

        scraper_classes[cls.NAME] = cls

    def __init__(self, verbose: bool = False):
        self.verbose = verbose
        self.session = requests.Session()
        self.session.headers = {
            "User-Agent": "github.com/defgsus/teletext-archive"
        }

    @classmethod
    def path(cls) -> Path:
        return cls.BASE_PATH / cls.NAME

    def iter_pages(self) -> Generator[Tuple[int, int, Union[str, bool]], None, None]:
        """
        Yield tuples of (page-number, sub-page-number, html-text)

        In cases that the content does not have changed except
        for the autogenerated date/time display in the teletext,
        one can yield True instead of the text to keep the file.
        See ZDF scraper as example.
        """
        raise NotImplementedError

    def download(self):
        os.makedirs(str(self.path()), exist_ok=True)
        for page_num, sub_page_num, content in self.iter_pages():
            if content is True:
                continue

            filename = self.path() / (
                f"{page_num:0{self.NUM_PAGE_DIGITS}}"
                f"-{sub_page_num:0{self.NUM_SUB_PAGE_DIGITS}}.{self.FILE_EXTENSION}"
            )
            self.log("storing", filename)
            filename.write_text(content)

    def log(self, *args):
        if self.verbose:
            print(f"{self.__class__.__name__}:", *args, file=sys.stderr)

    def get_html(self, url, **kwargs) -> requests.Response:
        kwargs.setdefault("timeout", self.REQUEST_TIMEOUT)
        self.log("requesting", url)
        return self.session.get(url, **kwargs)
